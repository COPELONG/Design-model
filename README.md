# 设计模式三原则

### 单一职责原则

封装、单一、耦合。

软件设计真正要做的事情就是，发现根据需求发现职责，并把这些职责进行分离，添加新的类，给当前类减负，越是这样项目才越容易维护。

### **开放封闭原则**

开放 -- 封闭原则说的是软件实体（类、模块、函数等）可以扩展，但是不可以修改。也就是说`对于扩展是开放的，对于修改是封闭的`。

### **依赖倒转原则**

1. `高层模块不应该依赖低层模块，两个都应该依赖抽象。`

2. `抽象不应该依赖细节，细节应该依赖抽象。`

   - 高层模块：可以理解为上层应用，就是业务层的实现

   - 低层模块：可以理解为底层接口，比如封装好的API、动态库等

   - 抽象：指的就是抽象类或者接口，在C++中没有接口，只有抽象类

     例如：由mysql换到Oracle，高层模块需要修改接口部分的代码。

# 简单工厂模式

定义一个工厂类，里面有一个static方法，通过传入不同的参数，返回一个来自同一个父类的派生类对象。

弊端：违反了开放-封闭原则，如果需要更多功能，需要在内部重新添加修改源代码。

# 工厂模式

简单工厂模式是只有一个工厂类，而工厂模式是有很多的工厂类：

- 一个基类，包含一个虚工厂函数，用于实现多态。
- 多个子类，重写父类的工厂函数。每个子工厂类负责生产一种功能，这相当于再次解耦，将工厂类的职责再次拆分、细化，如果要生产新功能，那么只需要添加对应的工厂类，无需修改原有的代码。
- 例：有两种水果apple和banana类，都继承水果类，实现专属自己的味道，再建造两座水果子工厂分别生产两种水果，最后使用多态的方法建造工厂并生产水果。

# 抽象工厂模式

例：

给一系列功能相同但是属性会发生变化的组件（如：船体材料、武器系统、动力系统）添加一个抽象类，这样就可以非常方便地进行后续的拓展，再构造一个船属性类，搭配工厂类就可以创建出我们需要的对象了。在工厂类中利用船属性类组装完整船。

### 关于简单工厂模式、工厂模式和抽象工厂模式的区别可以做如下总结：

1. 简单工厂模式不能遵守开放-封闭原则，工厂和抽象工厂模式可以
2. 简单工厂模式只有一个工厂类，工厂和抽象工厂有多个工厂类
3. 工厂模式创建的产品对象相对简单，抽象工厂模式创建的产品对象相对复杂

- 在工厂模式中，一个工厂类负责创建并返回产品对象

- 而在抽象工厂模式中，存在多个相关的工厂类，每个工厂类负责创建一组相关的产品对象。这些产品对象可能在结构和功能上更为复杂，它们通常由多个组件或子对象组成。

# 单例模式

在一个项目中，全局范围内，某个类的实例有且仅有一个，通过这个唯一实例向其他模块提供数据的全局访问，这种模式就叫单例模式。单例模式的典型应用就是任务队列。

- `构造函数：`创建一个新的对象   ：私有化
- `拷贝构造函数：`根据已有对象拷贝出一个新的对象  ：delete
- `拷贝赋值操作符重载函数：`两个对象之间的赋值 ：私有化或者delete

需要禁止以上方法创建多余的对象，

## 饿汉模式

```cpp
//饿汉模式：类加载的时候直接创建单例对象
singleton* singleton:: m_singleton=new singleton();
```

饿汉模式是没有线程安全问题的，在这种模式下访问单例对象的时候，这个对象已经被创建出来了。

## 饱汉模式

```cpp
//饱汉模式：使用的时候再去创建
singleton* singleton::m_singleton = nullptr;
```

存在多线程安全问题：使用互斥锁。可以将创建单例对象的代码使用互斥锁锁住

```cpp
	static singleton* Getsingleton() {
		if (m_singleton == nullptr) {//双重锁保证线程安全
			m_mutex.lock();
			if (m_singleton == nullptr) {
				return new singleton();
			}
			m_mutex.unlock();
		}
		return m_singleton;
	}
```

但是由于分配内存的时候顺序会有时不同，可能会导致其他线程导致使用还没有被分配内存的指针。

###### update1：

使用原子变量atomic的store() 方法来存储单例对象，使用load() 方法来加载单例对象

###### update2：

定义了一个静态局部对象，并且将这个对象作为了唯一的单例实例。

因为：如果指令逻辑进入一个未被初始化的声明变量，所有并发执行应当等待完成该变量完成初始化。

```cpp
	static singleton* Getinstance() {
		static singleton single;
		return &single;
	}
```

##### 懒汉模式和饿汉模式的区别：

懒汉模式的缺点是在创建实例对象的时候有安全问题，但这样可以减少内存的浪费（如果用不到就不去申请内存了）。饿汉模式则相反，在我们不需要这个实例对象的时候，它已经被创建出来，占用了一块内存。对于现在的计算机而言，内存容量都是足够大的，这个缺陷可以被无视。

# 适配器模式

**将一个类的接口转换成用户希望的另一个接口，使不兼容的对象能够相互配合并一起工作，这种模式就叫适配器模式。**

例如：人与动物对话需要一个中间翻译；电压转换的适配器等等。

# 代理模式

**为其他对象提供一种代理，以控制对这个对象的访问。**

例如：

通过信用卡、微信、支付宝等代替现金支付

通过VPN架梯子访问外网。

**如果使用代理模式，不能改变所代理的类的接口，使用代理模式的目的是为了加强控制。**

# 责任链模式

对于某个员工的请求可能需要一级一级向上传递，如果有权处理那就将其处理掉，如果无权处理还需继续向上传递该请求。**像上面这种将对象连成一条链，并沿着这条链传递请求，直到链上有一个对象将请求处理掉为止，这种处理数据的模式叫做责任链模式。使用这种模式有一个好处：处理者可以决定不再沿着链传递请求， 这可高效地取消所有后续处理步骤。**

**关键点：在处理请求之前必须先要把各个管理者对象按照等级关系串联起来：**

```cpp
 Manager* manager = new Manager;
 CEO* ceo = new CEO;
 Boss* boss = new Boss;
 // 设置关联关系
 manager->setNext(ceo);
 ceo->setNext(boss);
```

# 迭代器模式

**提供一种解决方案使其能够顺序访问一个集合对象中的各个元素，而又不暴露该集合底层的表现形式（列表、栈、树、图等），这种行为设计模式就叫迭代器模式。**

- 上课点名
- 上体育课报数
- 坐火车查票
- 躲在被窝里数钱
- STL容器的迭代器

# 观察者模式：

**观察者模式允许定义一种订阅机制，可在对象事件发生时通知所有的观察者对象，使它们能够自动更新。观察者模式还有另外一个名字叫做“发布-订阅”模式。**

观察者模式在日常生活中也很常见，比如：

- 使用的社交软件，当关注的博主更新了内容，会收到提示信息
- 购买的商品被送到菜鸟驿站，会收到驿站发送的提示信息
- 订阅了报刊，每天/每月都会收到新的报纸或者杂志

应用场景：**当一个对象的状态发生变化，并且需要改变其它对象的时候；或者当应用中一些对象必须观察其它对象的时候可以使用观察者模式。**

